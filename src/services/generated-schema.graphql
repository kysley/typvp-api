# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type Account {
  color: String
  confirmed: Boolean!
  createdAt: DateTime!
  email: String!
  id: String!
  lastPlayed: String
  lastSeen: DateTime
  password: String!
  role: Role!
  updatedAt: DateTime!
  username: String!
  usernameLowercase: String
  Test(where: TestWhereInput, orderBy: TestOrderByInput, skip: Int, after: TestWhereUniqueInput, before: TestWhereUniqueInput, first: Int, last: Int): [Test!]
  Trial(where: TrialWhereInput, orderBy: TrialOrderByInput, skip: Int, after: TrialWhereUniqueInput, before: TrialWhereUniqueInput, first: Int, last: Int): [Trial!]
}

input AccountCreateInput {
  color: String
  confirmed: Boolean
  createdAt: DateTime
  email: String!
  id: String
  lastPlayed: String
  lastSeen: DateTime
  password: String!
  role: Role
  updatedAt: DateTime
  username: String!
  usernameLowercase: String
  Test: TestCreateManyWithoutAccountInput
  Trial: TrialCreateManyWithoutAccountInput
}

input AccountCreateOneWithoutTestInput {
  create: AccountCreateWithoutTestInput
  connect: AccountWhereUniqueInput
}

input AccountCreateOneWithoutTrialInput {
  create: AccountCreateWithoutTrialInput
  connect: AccountWhereUniqueInput
}

input AccountCreateWithoutTestInput {
  color: String
  confirmed: Boolean
  createdAt: DateTime
  email: String!
  id: String
  lastPlayed: String
  lastSeen: DateTime
  password: String!
  role: Role
  updatedAt: DateTime
  username: String!
  usernameLowercase: String
  Trial: TrialCreateManyWithoutAccountInput
}

input AccountCreateWithoutTrialInput {
  color: String
  confirmed: Boolean
  createdAt: DateTime
  email: String!
  id: String
  lastPlayed: String
  lastSeen: DateTime
  password: String!
  role: Role
  updatedAt: DateTime
  username: String!
  usernameLowercase: String
  Test: TestCreateManyWithoutAccountInput
}

input AccountOrderByInput {
  color: OrderByArg
  confirmed: OrderByArg
  createdAt: OrderByArg
  email: OrderByArg
  id: OrderByArg
  lastPlayed: OrderByArg
  lastSeen: OrderByArg
  password: OrderByArg
  role: OrderByArg
  updatedAt: OrderByArg
  username: OrderByArg
  usernameLowercase: OrderByArg
}

input AccountUpdateInput {
  color: String
  confirmed: Boolean
  createdAt: DateTime
  email: String
  id: String
  lastPlayed: String
  lastSeen: DateTime
  password: String
  role: Role
  updatedAt: DateTime
  username: String
  usernameLowercase: String
  Test: TestUpdateManyWithoutAccountInput
  Trial: TrialUpdateManyWithoutAccountInput
}

input AccountUpdateManyMutationInput {
  color: String
  confirmed: Boolean
  createdAt: DateTime
  email: String
  id: String
  lastPlayed: String
  lastSeen: DateTime
  password: String
  role: Role
  updatedAt: DateTime
  username: String
  usernameLowercase: String
}

input AccountUpdateOneWithoutTestInput {
  create: AccountCreateWithoutTestInput
  connect: AccountWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: AccountUpdateWithoutTestDataInput
  upsert: AccountUpsertWithoutTestInput
}

input AccountUpdateOneWithoutTrialInput {
  create: AccountCreateWithoutTrialInput
  connect: AccountWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: AccountUpdateWithoutTrialDataInput
  upsert: AccountUpsertWithoutTrialInput
}

input AccountUpdateWithoutTestDataInput {
  color: String
  confirmed: Boolean
  createdAt: DateTime
  email: String
  id: String
  lastPlayed: String
  lastSeen: DateTime
  password: String
  role: Role
  updatedAt: DateTime
  username: String
  usernameLowercase: String
  Trial: TrialUpdateManyWithoutAccountInput
}

input AccountUpdateWithoutTrialDataInput {
  color: String
  confirmed: Boolean
  createdAt: DateTime
  email: String
  id: String
  lastPlayed: String
  lastSeen: DateTime
  password: String
  role: Role
  updatedAt: DateTime
  username: String
  usernameLowercase: String
  Test: TestUpdateManyWithoutAccountInput
}

input AccountUpsertWithoutTestInput {
  update: AccountUpdateWithoutTestDataInput!
  create: AccountCreateWithoutTestInput!
}

input AccountUpsertWithoutTrialInput {
  update: AccountUpdateWithoutTrialDataInput!
  create: AccountCreateWithoutTrialInput!
}

input AccountWhereInput {
  color: NullableStringFilter
  confirmed: BooleanFilter
  createdAt: DateTimeFilter
  email: StringFilter
  id: StringFilter
  lastPlayed: NullableStringFilter
  lastSeen: NullableDateTimeFilter
  password: StringFilter
  role: RoleFilter
  updatedAt: DateTimeFilter
  username: StringFilter
  usernameLowercase: NullableStringFilter
  Test: TestFilter
  Trial: TrialFilter
  AND: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  NOT: [AccountWhereInput!]
}

input AccountWhereUniqueInput {
  email: String
  id: String
  username: String
  usernameLowercase: String
}

type BatchPayload {
  count: Int!
}

input BooleanFilter {
  equals: Boolean
  not: Boolean
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  not: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
}

enum Difficulty {
  EASY
  NORMAL
  MEDIUM
  HARD
}

input IntFilter {
  equals: Int
  not: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
}

type Mutation {
  createOneAccount(data: AccountCreateInput!): Account!
  deleteOneAccount(where: AccountWhereUniqueInput!): Account
  updateOneAccount(data: AccountUpdateInput!, where: AccountWhereUniqueInput!): Account
  deleteManyAccount(where: AccountWhereInput): BatchPayload!
  updateManyAccount(data: AccountUpdateManyMutationInput!, where: AccountWhereInput): BatchPayload!
  upsertOneAccount(where: AccountWhereUniqueInput!, create: AccountCreateInput!, update: AccountUpdateInput!): Account!
  createOneTest(data: TestCreateInput!): Test!
  deleteOneTest(where: TestWhereUniqueInput!): Test
  updateOneTest(data: TestUpdateInput!, where: TestWhereUniqueInput!): Test
  deleteManyTest(where: TestWhereInput): BatchPayload!
  updateManyTest(data: TestUpdateManyMutationInput!, where: TestWhereInput): BatchPayload!
  upsertOneTest(where: TestWhereUniqueInput!, create: TestCreateInput!, update: TestUpdateInput!): Test!
  createOneTrial(data: TrialCreateInput!): Trial!
  deleteOneTrial(where: TrialWhereUniqueInput!): Trial
  updateOneTrial(data: TrialUpdateInput!, where: TrialWhereUniqueInput!): Trial
  deleteManyTrial(where: TrialWhereInput): BatchPayload!
  updateManyTrial(data: TrialUpdateManyMutationInput!, where: TrialWhereInput): BatchPayload!
  upsertOneTrial(where: TrialWhereUniqueInput!, create: TrialCreateInput!, update: TrialUpdateInput!): Trial!
}

input NullableBooleanFilter {
  equals: Boolean
  not: Boolean
}

input NullableDateTimeFilter {
  equals: DateTime
  not: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
}

input NullableDifficultyFilter {
  equals: Difficulty
  not: Difficulty
  in: [Difficulty!]
  notIn: [Difficulty!]
}

input NullableIntFilter {
  equals: Int
  not: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
}

input NullableStringFilter {
  equals: String
  not: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
}

enum OrderByArg {
  asc
  desc
}

type Query {
  account(where: AccountWhereUniqueInput!): Account
  accounts(where: AccountWhereInput, orderBy: AccountOrderByInput, skip: Int, after: AccountWhereUniqueInput, before: AccountWhereUniqueInput, first: Int, last: Int): [Account!]!
  test(where: TestWhereUniqueInput!): Test
  tests(where: TestWhereInput, orderBy: TestOrderByInput, skip: Int, after: TestWhereUniqueInput, before: TestWhereUniqueInput, first: Int, last: Int): [Test!]!
  trial(where: TrialWhereUniqueInput!): Trial
  trials(where: TrialWhereInput, orderBy: TrialOrderByInput, skip: Int, after: TrialWhereUniqueInput, before: TrialWhereUniqueInput, first: Int, last: Int): [Trial!]!
}

enum ResultType {
  SINGLEPLAYER
  RACE
  TRIAL
}

input ResultTypeFilter {
  equals: ResultType
  not: ResultType
  in: [ResultType!]
  notIn: [ResultType!]
}

enum Role {
  USER
  ADMIN
  PRO
  BETA
}

input RoleFilter {
  equals: Role
  not: Role
  in: [Role!]
  notIn: [Role!]
}

input StringFilter {
  equals: String
  not: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
}

type Test {
  account: String
  correct: Int!
  corrections: Int!
  cpm: Int!
  createdAt: DateTime!
  id: String!
  incorrect: Int!
  rawCpm: Int!
  type: ResultType!
  updatedAt: DateTime!
  wordIndex: Int!
  wpm: Int!
  Account: Account
  Trial(where: TrialWhereInput, orderBy: TrialOrderByInput, skip: Int, after: TrialWhereUniqueInput, before: TrialWhereUniqueInput, first: Int, last: Int): [Trial!]
}

input TestCreateInput {
  correct: Int!
  corrections: Int!
  cpm: Int!
  createdAt: DateTime
  id: String
  incorrect: Int!
  rawCpm: Int!
  type: ResultType!
  updatedAt: DateTime!
  wordIndex: Int!
  wpm: Int!
  Account: AccountCreateOneWithoutTestInput
  Trial: TrialCreateManyWithoutTestInput
}

input TestCreateManyWithoutAccountInput {
  create: [TestCreateWithoutAccountInput!]
  connect: [TestWhereUniqueInput!]
}

input TestCreateManyWithoutTrialInput {
  create: [TestCreateWithoutTrialInput!]
  connect: [TestWhereUniqueInput!]
}

input TestCreateWithoutAccountInput {
  correct: Int!
  corrections: Int!
  cpm: Int!
  createdAt: DateTime
  id: String
  incorrect: Int!
  rawCpm: Int!
  type: ResultType!
  updatedAt: DateTime!
  wordIndex: Int!
  wpm: Int!
  Trial: TrialCreateManyWithoutTestInput
}

input TestCreateWithoutTrialInput {
  correct: Int!
  corrections: Int!
  cpm: Int!
  createdAt: DateTime
  id: String
  incorrect: Int!
  rawCpm: Int!
  type: ResultType!
  updatedAt: DateTime!
  wordIndex: Int!
  wpm: Int!
  Account: AccountCreateOneWithoutTestInput
}

input TestFilter {
  every: TestWhereInput
  some: TestWhereInput
  none: TestWhereInput
}

input TestOrderByInput {
  account: OrderByArg
  correct: OrderByArg
  corrections: OrderByArg
  cpm: OrderByArg
  createdAt: OrderByArg
  id: OrderByArg
  incorrect: OrderByArg
  rawCpm: OrderByArg
  type: OrderByArg
  updatedAt: OrderByArg
  wordIndex: OrderByArg
  wpm: OrderByArg
  Account: OrderByArg
}

input TestScalarWhereInput {
  account: NullableStringFilter
  correct: IntFilter
  corrections: IntFilter
  cpm: IntFilter
  createdAt: DateTimeFilter
  id: StringFilter
  incorrect: IntFilter
  rawCpm: IntFilter
  type: ResultTypeFilter
  updatedAt: DateTimeFilter
  wordIndex: IntFilter
  wpm: IntFilter
  Trial: TrialFilter
  AND: [TestScalarWhereInput!]
  OR: [TestScalarWhereInput!]
  NOT: [TestScalarWhereInput!]
}

input TestUpdateInput {
  correct: Int
  corrections: Int
  cpm: Int
  createdAt: DateTime
  id: String
  incorrect: Int
  rawCpm: Int
  type: ResultType
  updatedAt: DateTime
  wordIndex: Int
  wpm: Int
  Account: AccountUpdateOneWithoutTestInput
  Trial: TrialUpdateManyWithoutTestInput
}

input TestUpdateManyDataInput {
  correct: Int
  corrections: Int
  cpm: Int
  createdAt: DateTime
  id: String
  incorrect: Int
  rawCpm: Int
  type: ResultType
  updatedAt: DateTime
  wordIndex: Int
  wpm: Int
}

input TestUpdateManyMutationInput {
  correct: Int
  corrections: Int
  cpm: Int
  createdAt: DateTime
  id: String
  incorrect: Int
  rawCpm: Int
  type: ResultType
  updatedAt: DateTime
  wordIndex: Int
  wpm: Int
}

input TestUpdateManyWithoutAccountInput {
  create: [TestCreateWithoutAccountInput!]
  connect: [TestWhereUniqueInput!]
  set: [TestWhereUniqueInput!]
  disconnect: [TestWhereUniqueInput!]
  delete: [TestWhereUniqueInput!]
  update: [TestUpdateWithWhereUniqueWithoutAccountInput!]
  updateMany: [TestUpdateManyWithWhereNestedInput!]
  deleteMany: [TestScalarWhereInput!]
  upsert: [TestUpsertWithWhereUniqueWithoutAccountInput!]
}

input TestUpdateManyWithoutTrialInput {
  create: [TestCreateWithoutTrialInput!]
  connect: [TestWhereUniqueInput!]
  set: [TestWhereUniqueInput!]
  disconnect: [TestWhereUniqueInput!]
  delete: [TestWhereUniqueInput!]
  update: [TestUpdateWithWhereUniqueWithoutTrialInput!]
  updateMany: [TestUpdateManyWithWhereNestedInput!]
  deleteMany: [TestScalarWhereInput!]
  upsert: [TestUpsertWithWhereUniqueWithoutTrialInput!]
}

input TestUpdateManyWithWhereNestedInput {
  where: TestScalarWhereInput!
  data: TestUpdateManyDataInput!
}

input TestUpdateWithoutAccountDataInput {
  correct: Int
  corrections: Int
  cpm: Int
  createdAt: DateTime
  id: String
  incorrect: Int
  rawCpm: Int
  type: ResultType
  updatedAt: DateTime
  wordIndex: Int
  wpm: Int
  Trial: TrialUpdateManyWithoutTestInput
}

input TestUpdateWithoutTrialDataInput {
  correct: Int
  corrections: Int
  cpm: Int
  createdAt: DateTime
  id: String
  incorrect: Int
  rawCpm: Int
  type: ResultType
  updatedAt: DateTime
  wordIndex: Int
  wpm: Int
  Account: AccountUpdateOneWithoutTestInput
}

input TestUpdateWithWhereUniqueWithoutAccountInput {
  where: TestWhereUniqueInput!
  data: TestUpdateWithoutAccountDataInput!
}

input TestUpdateWithWhereUniqueWithoutTrialInput {
  where: TestWhereUniqueInput!
  data: TestUpdateWithoutTrialDataInput!
}

input TestUpsertWithWhereUniqueWithoutAccountInput {
  where: TestWhereUniqueInput!
  update: TestUpdateWithoutAccountDataInput!
  create: TestCreateWithoutAccountInput!
}

input TestUpsertWithWhereUniqueWithoutTrialInput {
  where: TestWhereUniqueInput!
  update: TestUpdateWithoutTrialDataInput!
  create: TestCreateWithoutTrialInput!
}

input TestWhereInput {
  account: NullableStringFilter
  correct: IntFilter
  corrections: IntFilter
  cpm: IntFilter
  createdAt: DateTimeFilter
  id: StringFilter
  incorrect: IntFilter
  rawCpm: IntFilter
  type: ResultTypeFilter
  updatedAt: DateTimeFilter
  wordIndex: IntFilter
  wpm: IntFilter
  Trial: TrialFilter
  AND: [TestWhereInput!]
  OR: [TestWhereInput!]
  NOT: [TestWhereInput!]
  Account: AccountWhereInput
}

input TestWhereUniqueInput {
  id: String
}

type Trial {
  createdAt: DateTime!
  custom: Boolean
  difficulty: Difficulty
  id: String!
  maxWordLength: Int
  minWordLength: Int
  name: String!
  owner: String
  private: Boolean
  updatedAt: DateTime!
  wordSet: String!
  Account: Account
  Test(where: TestWhereInput, orderBy: TestOrderByInput, skip: Int, after: TestWhereUniqueInput, before: TestWhereUniqueInput, first: Int, last: Int): [Test!]
}

input TrialCreateInput {
  createdAt: DateTime
  custom: Boolean
  difficulty: Difficulty
  id: String
  maxWordLength: Int
  minWordLength: Int
  name: String!
  private: Boolean
  updatedAt: DateTime!
  wordSet: String!
  Account: AccountCreateOneWithoutTrialInput
  Test: TestCreateManyWithoutTrialInput
}

input TrialCreateManyWithoutAccountInput {
  create: [TrialCreateWithoutAccountInput!]
  connect: [TrialWhereUniqueInput!]
}

input TrialCreateManyWithoutTestInput {
  create: [TrialCreateWithoutTestInput!]
  connect: [TrialWhereUniqueInput!]
}

input TrialCreateWithoutAccountInput {
  createdAt: DateTime
  custom: Boolean
  difficulty: Difficulty
  id: String
  maxWordLength: Int
  minWordLength: Int
  name: String!
  private: Boolean
  updatedAt: DateTime!
  wordSet: String!
  Test: TestCreateManyWithoutTrialInput
}

input TrialCreateWithoutTestInput {
  createdAt: DateTime
  custom: Boolean
  difficulty: Difficulty
  id: String
  maxWordLength: Int
  minWordLength: Int
  name: String!
  private: Boolean
  updatedAt: DateTime!
  wordSet: String!
  Account: AccountCreateOneWithoutTrialInput
}

input TrialFilter {
  every: TrialWhereInput
  some: TrialWhereInput
  none: TrialWhereInput
}

input TrialOrderByInput {
  createdAt: OrderByArg
  custom: OrderByArg
  difficulty: OrderByArg
  id: OrderByArg
  maxWordLength: OrderByArg
  minWordLength: OrderByArg
  name: OrderByArg
  owner: OrderByArg
  private: OrderByArg
  updatedAt: OrderByArg
  wordSet: OrderByArg
  Account: OrderByArg
}

input TrialScalarWhereInput {
  createdAt: DateTimeFilter
  custom: NullableBooleanFilter
  difficulty: NullableDifficultyFilter
  id: StringFilter
  maxWordLength: NullableIntFilter
  minWordLength: NullableIntFilter
  name: StringFilter
  owner: NullableStringFilter
  private: NullableBooleanFilter
  updatedAt: DateTimeFilter
  wordSet: StringFilter
  Test: TestFilter
  AND: [TrialScalarWhereInput!]
  OR: [TrialScalarWhereInput!]
  NOT: [TrialScalarWhereInput!]
}

input TrialUpdateInput {
  createdAt: DateTime
  custom: Boolean
  difficulty: Difficulty
  id: String
  maxWordLength: Int
  minWordLength: Int
  name: String
  private: Boolean
  updatedAt: DateTime
  wordSet: String
  Account: AccountUpdateOneWithoutTrialInput
  Test: TestUpdateManyWithoutTrialInput
}

input TrialUpdateManyDataInput {
  createdAt: DateTime
  custom: Boolean
  difficulty: Difficulty
  id: String
  maxWordLength: Int
  minWordLength: Int
  name: String
  private: Boolean
  updatedAt: DateTime
  wordSet: String
}

input TrialUpdateManyMutationInput {
  createdAt: DateTime
  custom: Boolean
  difficulty: Difficulty
  id: String
  maxWordLength: Int
  minWordLength: Int
  name: String
  private: Boolean
  updatedAt: DateTime
  wordSet: String
}

input TrialUpdateManyWithoutAccountInput {
  create: [TrialCreateWithoutAccountInput!]
  connect: [TrialWhereUniqueInput!]
  set: [TrialWhereUniqueInput!]
  disconnect: [TrialWhereUniqueInput!]
  delete: [TrialWhereUniqueInput!]
  update: [TrialUpdateWithWhereUniqueWithoutAccountInput!]
  updateMany: [TrialUpdateManyWithWhereNestedInput!]
  deleteMany: [TrialScalarWhereInput!]
  upsert: [TrialUpsertWithWhereUniqueWithoutAccountInput!]
}

input TrialUpdateManyWithoutTestInput {
  create: [TrialCreateWithoutTestInput!]
  connect: [TrialWhereUniqueInput!]
  set: [TrialWhereUniqueInput!]
  disconnect: [TrialWhereUniqueInput!]
  delete: [TrialWhereUniqueInput!]
  update: [TrialUpdateWithWhereUniqueWithoutTestInput!]
  updateMany: [TrialUpdateManyWithWhereNestedInput!]
  deleteMany: [TrialScalarWhereInput!]
  upsert: [TrialUpsertWithWhereUniqueWithoutTestInput!]
}

input TrialUpdateManyWithWhereNestedInput {
  where: TrialScalarWhereInput!
  data: TrialUpdateManyDataInput!
}

input TrialUpdateWithoutAccountDataInput {
  createdAt: DateTime
  custom: Boolean
  difficulty: Difficulty
  id: String
  maxWordLength: Int
  minWordLength: Int
  name: String
  private: Boolean
  updatedAt: DateTime
  wordSet: String
  Test: TestUpdateManyWithoutTrialInput
}

input TrialUpdateWithoutTestDataInput {
  createdAt: DateTime
  custom: Boolean
  difficulty: Difficulty
  id: String
  maxWordLength: Int
  minWordLength: Int
  name: String
  private: Boolean
  updatedAt: DateTime
  wordSet: String
  Account: AccountUpdateOneWithoutTrialInput
}

input TrialUpdateWithWhereUniqueWithoutAccountInput {
  where: TrialWhereUniqueInput!
  data: TrialUpdateWithoutAccountDataInput!
}

input TrialUpdateWithWhereUniqueWithoutTestInput {
  where: TrialWhereUniqueInput!
  data: TrialUpdateWithoutTestDataInput!
}

input TrialUpsertWithWhereUniqueWithoutAccountInput {
  where: TrialWhereUniqueInput!
  update: TrialUpdateWithoutAccountDataInput!
  create: TrialCreateWithoutAccountInput!
}

input TrialUpsertWithWhereUniqueWithoutTestInput {
  where: TrialWhereUniqueInput!
  update: TrialUpdateWithoutTestDataInput!
  create: TrialCreateWithoutTestInput!
}

input TrialWhereInput {
  createdAt: DateTimeFilter
  custom: NullableBooleanFilter
  difficulty: NullableDifficultyFilter
  id: StringFilter
  maxWordLength: NullableIntFilter
  minWordLength: NullableIntFilter
  name: StringFilter
  owner: NullableStringFilter
  private: NullableBooleanFilter
  updatedAt: DateTimeFilter
  wordSet: StringFilter
  Test: TestFilter
  AND: [TrialWhereInput!]
  OR: [TrialWhereInput!]
  NOT: [TrialWhereInput!]
  Account: AccountWhereInput
}

input TrialWhereUniqueInput {
  id: String
}
