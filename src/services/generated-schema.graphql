# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type Account {
  color: String
  confirmed: Boolean!
  createdAt: DateTime!
  email: String!
  id: String!
  lastPlayed: ResultType
  lastSeen: DateTime!
  password: String!
  role: Role!
  tests(after: TestWhereUniqueInput, before: TestWhereUniqueInput, first: Int, last: Int, orderBy: TestOrderByInput, skip: Int, where: TestWhereInput): [Test!]
  trials(after: TrialWhereUniqueInput, before: TrialWhereUniqueInput, first: Int, last: Int, orderBy: TrialOrderByInput, skip: Int, where: TrialWhereInput): [Trial!]
  updatedAt: DateTime!
  username: String!
  usernameLowercase: String
}

input AccountLoginInput {
  password: String!
  username: String!
}

type accountResultsResponse {
  count: Int!
  results: [Test!]!
}

input AccountWhereInput {
  AND: [AccountWhereInput!]
  color: NullableStringFilter
  confirmed: BooleanFilter
  createdAt: DateTimeFilter
  email: StringFilter
  id: StringFilter
  lastPlayed: NullableResultTypeFilter
  lastSeen: DateTimeFilter
  NOT: [AccountWhereInput!]
  OR: [AccountWhereInput!]
  password: StringFilter
  role: RoleFilter
  tests: TestFilter
  trials: TrialFilter
  updatedAt: DateTimeFilter
  username: StringFilter
  usernameLowercase: NullableStringFilter
}

input AccountWhereUniqueInput {
  email: String
  id: String
  username: String
  usernameLowercase: String
}

type AuthPayload {
  account: Account!
  token: String!
}

input BooleanFilter {
  equals: Boolean
  not: Boolean
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

enum Difficulty {
  EASY
  HARD
  MEDIUM
  NORMAL
}

input ExclusiveAccountCreateInput {
  email: String!
  password: String!
  username: String!
}

input ExclusiveAccountUpdateInput {
  color: String
  email: String
}

input ExclusiveCreateOneTestInput {
  correct: Int!
  corrections: Int!
  cpm: Int!
  incorrect: Int!
  rawCpm: Int!
  wordIndex: Int!
  wpm: Int!
}

input ExclusiveUpdateOneTrialInput {
  name: String
  private: Boolean
  wordSet: String
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

type Mutation {
  createAccount(data: ExclusiveAccountCreateInput!): AuthPayload!
  createNewResult(data: ExclusiveCreateOneTestInput!): Boolean!
  createPersonalWordset(wordSet: String!): Boolean!
  deleteTrial(trialId: ID!): Trial!
  login(test: AccountLoginInput!): AuthPayload!
  updateAccount(data: ExclusiveAccountUpdateInput!): Account!
  updateTrial(data: ExclusiveUpdateOneTrialInput!, where: TrialWhereUniqueInput!): Trial!
}

input NullableBooleanFilter {
  equals: Boolean
  not: Boolean
}

input NullableDifficultyFilter {
  equals: Difficulty
  in: [Difficulty!]
  not: Difficulty
  notIn: [Difficulty!]
}

input NullableIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

input NullableResultTypeFilter {
  equals: ResultType
  in: [ResultType!]
  not: ResultType
  notIn: [ResultType!]
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

enum OrderByArg {
  asc
  desc
}

type Query {
  account(where: AccountWhereUniqueInput!): Account
  accountResults(after: TestWhereUniqueInput, before: TestWhereUniqueInput, first: Int, id: String!, last: Int, orderBy: TestOrderByInput, skip: Int, where: TestWhereInput): accountResultsResponse!
  getWordset: String!
  leaderboard(after: TestWhereUniqueInput, before: TestWhereUniqueInput, first: Int, last: Int, orderBy: TestOrderByInput, skip: Int, where: TestWhereInput): [Test!]!
  me: Account
  trial(where: TrialWhereUniqueInput!): Trial
  trialLeaders(trialId: ID!): [Test!]!
  trials(after: TrialWhereUniqueInput, before: TrialWhereUniqueInput, first: Int, last: Int, orderBy: TrialOrderByInput, skip: Int, where: TrialWhereInput): [Trial!]!
}

enum ResultType {
  RACE
  SINGLEPLAYER
  TRIAL
}

input ResultTypeFilter {
  equals: ResultType
  in: [ResultType!]
  not: ResultType
  notIn: [ResultType!]
}

enum Role {
  ADMIN
  BETA
  PRO
  USER
}

input RoleFilter {
  equals: Role
  in: [Role!]
  not: Role
  notIn: [Role!]
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Test {
  account: Account!
  accountId: String!
  correct: Int!
  corrections: Int!
  cpm: Int!
  createdAt: DateTime!
  id: String!
  incorrect: Int!
  rawCpm: Int!
  trial: Trial
  trialId: String
  type: ResultType!
  updatedAt: DateTime!
  wordIndex: Int!
  wpm: Int!
}

input TestFilter {
  every: TestWhereInput
  none: TestWhereInput
  some: TestWhereInput
}

input TestOrderByInput {
  account: OrderByArg
  accountId: OrderByArg
  correct: OrderByArg
  corrections: OrderByArg
  cpm: OrderByArg
  createdAt: OrderByArg
  id: OrderByArg
  incorrect: OrderByArg
  rawCpm: OrderByArg
  trial: OrderByArg
  trialId: OrderByArg
  type: OrderByArg
  updatedAt: OrderByArg
  wordIndex: OrderByArg
  wpm: OrderByArg
}

input TestWhereInput {
  account: AccountWhereInput
  accountId: StringFilter
  AND: [TestWhereInput!]
  correct: IntFilter
  corrections: IntFilter
  cpm: IntFilter
  createdAt: DateTimeFilter
  id: StringFilter
  incorrect: IntFilter
  NOT: [TestWhereInput!]
  OR: [TestWhereInput!]
  rawCpm: IntFilter
  trial: TrialWhereInput
  trialId: NullableStringFilter
  type: ResultTypeFilter
  updatedAt: DateTimeFilter
  wordIndex: IntFilter
  wpm: IntFilter
}

input TestWhereUniqueInput {
  id: String
}

type Trial {
  createdAt: DateTime!
  custom: Boolean
  difficulty: Difficulty
  id: String!
  maxWordLength: Int
  minWordLength: Int
  name: String!
  owner: Account
  ownerId: String
  private: Boolean
  results(after: TestWhereUniqueInput, before: TestWhereUniqueInput, first: Int, last: Int, orderBy: TestOrderByInput, skip: Int, where: TestWhereInput): [Test!]
  updatedAt: DateTime!
  wordSet: String!
}

input TrialFilter {
  every: TrialWhereInput
  none: TrialWhereInput
  some: TrialWhereInput
}

input TrialOrderByInput {
  createdAt: OrderByArg
  custom: OrderByArg
  difficulty: OrderByArg
  id: OrderByArg
  maxWordLength: OrderByArg
  minWordLength: OrderByArg
  name: OrderByArg
  owner: OrderByArg
  ownerId: OrderByArg
  private: OrderByArg
  updatedAt: OrderByArg
  wordSet: OrderByArg
}

input TrialWhereInput {
  AND: [TrialWhereInput!]
  createdAt: DateTimeFilter
  custom: NullableBooleanFilter
  difficulty: NullableDifficultyFilter
  id: StringFilter
  maxWordLength: NullableIntFilter
  minWordLength: NullableIntFilter
  name: StringFilter
  NOT: [TrialWhereInput!]
  OR: [TrialWhereInput!]
  owner: AccountWhereInput
  ownerId: NullableStringFilter
  private: NullableBooleanFilter
  results: TestFilter
  updatedAt: DateTimeFilter
  wordSet: StringFilter
}

input TrialWhereUniqueInput {
  id: String
}
